//
// ServiceTTS.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ServiceTTS: Codable, JSONEncodable, Hashable {

    public enum Voice: String, Codable, CaseIterable {
        case femaleSlashEnUs = "female/en-US"
        case maleSlashEnUs = "male/en-US"
        case femaleSlashEnCa = "female/en-CA"
        case femaleSlashEnAu = "female/en-AU"
        case femaleSlashEnGb = "female/en-GB"
        case maleSlashEnGb = "male/en-GB"
        case femaleSlashEsUs = "female/es-US"
        case maleSlashEsUs = "male/es-US"
        case femaleSlashUsUs = "female/us-US"
        case femaleSlashZhCn = "female/zh-CN"
        case maleSlashZhCn = "male/zh-CN"
        case femaleSlashZhHk = "female/zh-HK"
        case femaleSlashZhTw = "female/zh-TW"
        case femaleSlashJaJp = "female/ja-JP"
        case maleSlashJaJp = "male/ja-JP"
        case femaleSlashKoKr = "female/ko-KR"
        case maleSlashKoKr = "male/ko-KR"
        case femaleSlashDaDk = "female/da-DK"
        case femaleSlashDeDe = "female/de-DE"
        case maleSlashDeDe = "male/de-DE"
        case femaleSlashCaEs = "female/ca-ES"
        case femaleSlashEsEs = "female/es-ES"
        case maleSlashEsEs = "male/es-ES"
        case femaleSlashFiFi = "female/fi-FI"
        case femaleSlashFrCa = "female/fr-CA"
        case maleSlashFrCa = "male/fr-CA"
        case femaleSlashFrFr = "female/fr-FR"
        case maleSlashFrFr = "male/fr-FR"
        case femaleSlashItIt = "female/it-IT"
        case maleSlashItIt = "male/it-IT"
        case femaleSlashNbNo = "female/nb-NO"
        case femaleSlashNlNl = "female/nl-NL"
        case femaleSlashPlPl = "female/pl-PL"
        case femaleSlashPtBr = "female/pt-BR"
        case femaleSlashPtPt = "female/pt-PT"
        case maleSlashPtPt = "male/pt-PT"
        case femaleSlashRuRu = "female/ru-RU"
        case maleSlashRuRu = "male/ru-RU"
        case femaleSlashSvSe = "female/sv-SE"
        case femaleSlashHuHu = "female/hu-HU"
        case femaleSlashCsCz = "female/cs-CZ"
        case femaleSlashTrTr = "female/tr-TR"
        case maleSlashTrTr = "male/tr-TR"
        case maleSlashRuRuSlashVladimir = "male/ru-RU/Vladimir"
        case femaleSlashRuRuSlashJulia = "female/ru-RU/Julia"
        case femaleSlashRuRuSlashAnna = "female/ru-RU/Anna"
        case femaleSlashRuRuSlashViktoria = "female/ru-RU/Viktoria"
        case maleSlashRuRuSlashAlexander = "male/ru-RU/Alexander"
        case femaleSlashRuRuSlashMaria = "female/ru-RU/Maria"
        case femaleSlashRuRuSlashLidia = "female/ru-RU/Lidia"
        case esEsStandardA = "es-ES-Standard-A"
        case itItStandardA = "it-IT-Standard-A"
        case jaJpStandardA = "ja-JP-Standard-A"
        case koKrStandardA = "ko-KR-Standard-A"
        case ptBrStandardA = "pt-BR-Standard-A"
        case trTrStandardA = "tr-TR-Standard-A"
        case svSeStandardA = "sv-SE-Standard-A"
        case nlNlStandardA = "nl-NL-Standard-A"
        case enUsWavenetD = "en-US-Wavenet-D"
        case deDeWavenetA = "de-DE-Wavenet-A"
        case deDeWavenetB = "de-DE-Wavenet-B"
        case deDeWavenetC = "de-DE-Wavenet-C"
        case deDeWavenetD = "de-DE-Wavenet-D"
        case enAuWavenetA = "en-AU-Wavenet-A"
        case enAuWavenetB = "en-AU-Wavenet-B"
        case enAuWavenetC = "en-AU-Wavenet-C"
        case enAuWavenetD = "en-AU-Wavenet-D"
        case enGbWavenetA = "en-GB-Wavenet-A"
        case enGbWavenetB = "en-GB-Wavenet-B"
        case enGbWavenetC = "en-GB-Wavenet-C"
        case enGbWavenetD = "en-GB-Wavenet-D"
        case enUsWavenetA = "en-US-Wavenet-A"
        case enUsWavenetB = "en-US-Wavenet-B"
        case enUsWavenetC = "en-US-Wavenet-C"
        case enUsWavenetE = "en-US-Wavenet-E"
        case enUsWavenetF = "en-US-Wavenet-F"
        case frFrWavenetA = "fr-FR-Wavenet-A"
        case frFrWavenetB = "fr-FR-Wavenet-B"
        case frFrWavenetC = "fr-FR-Wavenet-C"
        case frFrWavenetD = "fr-FR-Wavenet-D"
        case itItWavenetA = "it-IT-Wavenet-A"
        case jaJpWavenetA = "ja-JP-Wavenet-A"
        case nlNlWavenetA = "nl-NL-Wavenet-A"
        case enGbStandardA = "en-GB-Standard-A"
        case enGbStandardB = "en-GB-Standard-B"
        case enGbStandardC = "en-GB-Standard-C"
        case enGbStandardD = "en-GB-Standard-D"
        case enUsStandardB = "en-US-Standard-B"
        case enUsStandardC = "en-US-Standard-C"
        case enUsStandardD = "en-US-Standard-D"
        case enUsStandardE = "en-US-Standard-E"
        case deDeStandardA = "de-DE-Standard-A"
        case deDeStandardB = "de-DE-Standard-B"
        case enAuStandardA = "en-AU-Standard-A"
        case enAuStandardB = "en-AU-Standard-B"
        case enAuStandardC = "en-AU-Standard-C"
        case enAuStandardD = "en-AU-Standard-D"
        case frCaStandardA = "fr-CA-Standard-A"
        case frCaStandardB = "fr-CA-Standard-B"
        case frCaStandardC = "fr-CA-Standard-C"
        case frCaStandardD = "fr-CA-Standard-D"
        case frFrStandardA = "fr-FR-Standard-A"
        case frFrStandardB = "fr-FR-Standard-B"
        case frFrStandardC = "fr-FR-Standard-C"
        case frFrStandardD = "fr-FR-Standard-D"
    }
    public var text: String
    public var voice: Voice?

    public init(text: String, voice: Voice? = nil) {
        self.text = text
        self.voice = voice
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case text
        case voice
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(text, forKey: .text)
        try container.encodeIfPresent(voice, forKey: .voice)
    }
}

