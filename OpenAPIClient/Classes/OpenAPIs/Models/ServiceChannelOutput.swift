//
// ServiceChannelOutput.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ServiceChannelOutput: Codable, JSONEncodable, Hashable {

    public var answered: Bool?
    public var authorizingId: String?
    public var authorizingType: String?
    public var callflowId: String?
    public var channelAuthorized: Bool?
    public var customApplicationVars: [String: AnyCodable]?
    public var customAuthHeaders: [String: AnyCodable]?
    public var customChannelVars: [String: AnyCodable]?
    public var customSipHeaders: [String: AnyCodable]?
    public var destination: String?
    public var direction: String?
    public var elapsedS: Int?
    public var fromTag: String?
    public var interactionId: String?
    public var isLoopback: Bool?
    public var isOnhold: Bool?
    public var otherLeg: String?
    public var ownerId: String?
    public var presenceId: String?
    public var request: String?
    public var resellerId: String?
    public var timestamp: Int?
    public var toTag: String?
    public var username: String?
    public var uuid: String?

    public init(answered: Bool? = nil, authorizingId: String? = nil, authorizingType: String? = nil, callflowId: String? = nil, channelAuthorized: Bool? = nil, customApplicationVars: [String: AnyCodable]? = nil, customAuthHeaders: [String: AnyCodable]? = nil, customChannelVars: [String: AnyCodable]? = nil, customSipHeaders: [String: AnyCodable]? = nil, destination: String? = nil, direction: String? = nil, elapsedS: Int? = nil, fromTag: String? = nil, interactionId: String? = nil, isLoopback: Bool? = nil, isOnhold: Bool? = nil, otherLeg: String? = nil, ownerId: String? = nil, presenceId: String? = nil, request: String? = nil, resellerId: String? = nil, timestamp: Int? = nil, toTag: String? = nil, username: String? = nil, uuid: String? = nil) {
        self.answered = answered
        self.authorizingId = authorizingId
        self.authorizingType = authorizingType
        self.callflowId = callflowId
        self.channelAuthorized = channelAuthorized
        self.customApplicationVars = customApplicationVars
        self.customAuthHeaders = customAuthHeaders
        self.customChannelVars = customChannelVars
        self.customSipHeaders = customSipHeaders
        self.destination = destination
        self.direction = direction
        self.elapsedS = elapsedS
        self.fromTag = fromTag
        self.interactionId = interactionId
        self.isLoopback = isLoopback
        self.isOnhold = isOnhold
        self.otherLeg = otherLeg
        self.ownerId = ownerId
        self.presenceId = presenceId
        self.request = request
        self.resellerId = resellerId
        self.timestamp = timestamp
        self.toTag = toTag
        self.username = username
        self.uuid = uuid
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case answered
        case authorizingId = "authorizing_id"
        case authorizingType = "authorizing_type"
        case callflowId = "callflow_id"
        case channelAuthorized = "channel_authorized"
        case customApplicationVars = "custom_application_vars"
        case customAuthHeaders = "custom_auth_headers"
        case customChannelVars = "custom_channel_vars"
        case customSipHeaders = "custom_sip_headers"
        case destination
        case direction
        case elapsedS = "elapsed_s"
        case fromTag = "from_tag"
        case interactionId = "interaction_id"
        case isLoopback = "is_loopback"
        case isOnhold = "is_onhold"
        case otherLeg = "other_leg"
        case ownerId = "owner_id"
        case presenceId = "presence_id"
        case request
        case resellerId = "reseller_id"
        case timestamp
        case toTag = "to_tag"
        case username
        case uuid
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(answered, forKey: .answered)
        try container.encodeIfPresent(authorizingId, forKey: .authorizingId)
        try container.encodeIfPresent(authorizingType, forKey: .authorizingType)
        try container.encodeIfPresent(callflowId, forKey: .callflowId)
        try container.encodeIfPresent(channelAuthorized, forKey: .channelAuthorized)
        try container.encodeIfPresent(customApplicationVars, forKey: .customApplicationVars)
        try container.encodeIfPresent(customAuthHeaders, forKey: .customAuthHeaders)
        try container.encodeIfPresent(customChannelVars, forKey: .customChannelVars)
        try container.encodeIfPresent(customSipHeaders, forKey: .customSipHeaders)
        try container.encodeIfPresent(destination, forKey: .destination)
        try container.encodeIfPresent(direction, forKey: .direction)
        try container.encodeIfPresent(elapsedS, forKey: .elapsedS)
        try container.encodeIfPresent(fromTag, forKey: .fromTag)
        try container.encodeIfPresent(interactionId, forKey: .interactionId)
        try container.encodeIfPresent(isLoopback, forKey: .isLoopback)
        try container.encodeIfPresent(isOnhold, forKey: .isOnhold)
        try container.encodeIfPresent(otherLeg, forKey: .otherLeg)
        try container.encodeIfPresent(ownerId, forKey: .ownerId)
        try container.encodeIfPresent(presenceId, forKey: .presenceId)
        try container.encodeIfPresent(request, forKey: .request)
        try container.encodeIfPresent(resellerId, forKey: .resellerId)
        try container.encodeIfPresent(timestamp, forKey: .timestamp)
        try container.encodeIfPresent(toTag, forKey: .toTag)
        try container.encodeIfPresent(username, forKey: .username)
        try container.encodeIfPresent(uuid, forKey: .uuid)
    }
}

